# Слайсы, Мапы
++++++++++
 Задача 1
++++++++++
Что выведет код?
```go
func main() {
	v := []int{3, 4, 1, 2, 5}
	ap(v)
	sr(v)
	fmt.Println(v)
}

func ap(arr []int) {
	arr = append(arr, 10)
}

func sr(arr []int) {
	sort.Ints(arr)
}
```
Output: [1 2 3 4 5]. Пояснение: Функция ap не сработала, потому что в Go аргументы передаются по значению, а не по ссылке. Когда вы передаете срез arr в функцию ap, создается копия этого среза. Изменения, сделанные в копии, не влияют на оригинальный срез.

++++++++++
 Задача 2
++++++++++
Что выведет код?

```go
var foo []int
var bar []int

foo = append(foo, 1)
foo = append(foo, 2)
foo = append(foo, 3)
bar = append(foo, 4)
foo = append(foo, 5)

fmt.Println(foo, bar)
```
Output: [1 2 3 5] [1 2 3 5]. Пояснение: В вашем коде переменная bar не содержит ожидаемых значений, потому что она ссылается на тот же базовый массив, что и foo, в момент вызова append(foo, 4). Когда вы добавляете элемент 5 в foo, это изменение также влияет на bar.

++++++++++
 Задача 3
++++++++++
Что выведется?
```go
package main
import "fmt"
func main() {
  c := []string{"A", "B", "D", "E"}
  b := c[1:2]
  b = append(b, "TT")
  fmt.Println(c)
  fmt.Println(b)
}
```
Output: [A B TT E]
	[B TT]
Пояснение: В вашем коде, когда вы выполняете append(b, "TT"), это может изменить базовый массив, на который ссылается срез c.

++++++++++
 Задача 4
++++++++++
1. Что выведет код?

```go
func main() {
  var m map[string]int
  for _, word := range []string{"hello", "world", "from", "the",
    "best", "language", "in", "the", "world"} {
    m[word]++
  }
  for k, v := range m {
    fmt.Println(k, v)
  }
}
```
Output: panic. Пояснение: код не работает, потому что не инициализировали карту m. В Go карты нужно инициализировать перед использованием, иначе попытка доступа к ним приведет к панике (runtime panic)/
Fix: инициализировать мапу через make.

++++++++++
 Задача 5
++++++++++
1. Что будет в результате выполнения?
```go
mutate := func(a []int) {
  a[0] = 0
  a = append(a, 1)
  fmt.Println(a)
}
a := []int{1, 2, 3, 4}
mutate(a)
fmt.Println(a)
```
Output:[0 2 3 4 1] 
       [0 2 3 4]
Пояснение: Изменение элемента слайса внутри функции влияет на исходный слайс, но добавление элемента с помощью append создает новый слайс, не изменяя исходный.

++++++++++
 Задача 6
++++++++++
1. Что выведется?
2. Зная обо всех таких нюансах, которые могут возникнуть, какие есть рекомендации?

------Вариант 1
-----------
```go
func mod(a []int) {
  for i := range a {
    a[i] = 5
  }
  fmt.Println(a)
}
func main() {
  sl := []int{1, 2, 3, 5}
  mod(sl)
  fmt.Println(sl)
}
```
Output: [5 5 5 5 5][5 5 5 5 5].
Если за нюанс мы принимаем тот факт, что изменяется оригинальный слайс, то стоит просто передавать в функцию его копию.

code fix:
```go
func mod(a []int) {
    b := make([]int, len(a), len(a))
    copy(b, a)
    for i := range b {
        b[i] = 5
    }
    fmt.Println(b)
}

func main() {
    sl := []int{1, 2, 3, 5}
    mod(sl)
    fmt.Println(sl) // Вывод:
}
```
------ Вариант 2
по аналогии с вар 1
------ Вариант 3
по аналогии с вар 1
------ Вариант 4
почти по аналогии с вар 1. Исключением является то, что тут не меняется базовый массив. А не меняется он потому что при вызове функции append() емкость слайса уже заполнена и он просто создает новый слайс в котором и проводит все последующие операции.

++++++++++
 Задача 7
++++++++++
1. Что будет содержать s после инициализации?
2. Что произойдет в println для слайса и для мапы?
```go
func a(s []int) {
    s = append(s, 37)
}

func b(m map[int]int) {
    m[3] = 33
}

func main() {
    s := make([]int, 3, 8)
    m := make(map[int]int, 8)

    // add to slice
    a(s)
    println(s[3]) //?

    // add to map
    b(m)
    println(m[3]) //?
}
```
1. После инициализации s будет содержать 3 нуля "пустые" значения типа int. 
2. При попытке вывода println(s[3]) будет паника, так как в слайсе всего 3 элемента, а мы пытаемся достать 4. При выводе мапы будет видно измененное значение с индексом 3, т.е 33.


++++++++++
 Задача 8
++++++++++
1. Расскажи подробно что происходит

Вариант 1
-----------
```go
package main

import "fmt"

func main() {
    a := []int{1,2}
    a = append(a, 3)
    b := append(a, 4)
    c := append(a, 5)

    fmt.Println(b)
    fmt.Println(c)
}
```
Output: [1 2 3 5] [1 2 3 5]
Пояснение: Создание и изменение слайса a:
a := []int{1, 2} создает слайс a с элементами [1, 2].
a = append(a, 3) добавляет элемент 3 к слайсу a, и теперь a содержит [1, 2, 3].
Создание слайсов b и c:
b := append(a, 4) создает новый слайс b, добавляя элемент 4 к слайсу a. Теперь b содержит [1, 2, 3, 4].
c := append(a, 5) создает новый слайс c, добавляя элемент 5 к слайсу a. Теперь c содержит [1, 2, 3, 5].
Изменение базового массива:
Когда вы вызываете append(a, 4) и append(a, 5), оба вызова могут использовать один и тот же базовый массив, если емкость позволяет. В данном случае, емкость слайса a позволяет добавить элементы без выделения новой памяти.
Поэтому, когда вы добавляете 5 к слайсу a, это изменение также влияет на слайс b, так как они используют один и тот же базовый массив.
Вывод слайсов:
fmt.Println(b) выводит [1, 2, 3, 5], так как базовый массив был изменен при добавлении 5 к слайсу a.
fmt.Println(c) также выводит [1, 2, 3, 5] по той же причине.

Вариант 2
-----------
```go
package main

import "fmt"

func main() {
    a := []int{1,2}
    a = append(a, 3)
    a = append(a, 7)
    b := append(a, 4)
    c := append(a, 5)

    fmt.Println(b)
    fmt.Println(c)
}

```
Output: [1 2 3 7 4] [1 2 3 7 5].
Пояснение:Создание и изменение слайса a:
a := []int{1, 2} создает слайс a с элементами [1, 2].
a = append(a, 3) добавляет элемент 3 к слайсу a, и теперь a содержит [1, 2, 3].
a = append(a, 7) добавляет элемент 7 к слайсу a, и теперь a содержит [1, 2, 3, 7].
Создание слайсов b и c:
b := append(a, 4) создает новый слайс b, добавляя элемент 4 к слайсу a. Теперь b содержит [1, 2, 3, 7, 4].
c := append(a, 5) создает новый слайс c, добавляя элемент 5 к слайсу a. Теперь c содержит [1, 2, 3, 7, 5].
Изменение базового массива:
Когда вы вызываете append(a, 4), емкость слайса a может быть достаточной для добавления элемента без выделения новой памяти. В этом случае b и a будут указывать на один и тот же базовый массив.
Однако, когда вы вызываете append(a, 5), если емкость слайса a недостаточна, создается новый базовый массив, и c начинает указывать на этот новый массив.
Вывод слайсов:
fmt.Println(b) выводит [1, 2, 3, 7, 4], так как b указывает на исходный базовый массив, который был изменен при добавлении 4.
fmt.Println(c) выводит [1, 2, 3, 7, 5], так как c указывает на новый базовый массив, который был создан при добавлении 5.




# Многопоточка
++++++++++
 Задача 1
++++++++++
Что выведет код? Исправить все проблемы
```go
func main() {
	ch := make(chan int)
	wg := &sync.WaitGroup{}
	wg.Add(3)
	for i := 0; i < 3; i++ {
		go func(v int) {
			defer wg.Done()
			ch <- v * v
		}(i)
	}
	wg.Wait()
	var sum int
	for v := range ch {
		sum += v
	}
	fmt.Printf("result: %d\n", sum)
}
```
Output: result: 5.
Fix code
```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	ch := make(chan int)
	wg := &sync.WaitGroup{}
	wg.Add(3)
	for i := 0; i < 3; i++ {
		go func(v int) {
			defer wg.Done()
			ch <- v * v
		}(i)
	}

	// Закрываем канал после завершения всех горутин
	go func() {
		wg.Wait()
		close(ch)
	}()

	var sum int
	for v := range ch {
		sum += v
	}
	fmt.Printf("result: %d\n", sum)
}
```
Пояснение:
Закрытие канала:
Канал ch никогда не закрывается, что приводит к бесконечному ожиданию в цикле for v := range ch. Это вызывает deadlock.
Чтение из канала после завершения всех горутин:
Вы пытаетесь читать из канала после завершения всех горутин, но не указываете, когда чтение должно прекратиться.

++++++++++
 Задача 2
++++++++++
Что выведет код? Должны выводится все значения
```go
func main() {
	a := 5000
	for i := 0; i < a; i++ {
		go fmt.Println(i)
	}
}
```
Output: код запускает 5000 горутин, каждая из которых выводит число от 0 дл 4999. есть потециальная проблема: main функция может завершиться до того, как все горутины завершат выполнение, что в свою очередь ведет к неполному выводу или его отсутствию. Для предотвращения сего безобразия можно использовать WaitGroup из пакета sync. Код будет выглядеть следующим образом:
```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	var wg sync.WaitGroup
	a := 5000

	for i := 0; i < a; i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			fmt.Println(i)
		}(i)
	}

	wg.Wait()
}
```

++++++++++
 Задача 3
++++++++++
Будет ошибка что все горутины заблокированы. Какие горутины будут заблокированы? И почему?
```go
package main
import "fmt"
func main() {
  ch := make(chan int)
  ch <- 1
  go func() {
    fmt.Println(<-ch)
  }()
}
```
Главная горутина(main func) будет заблокирована, потому что мы пытаемся отправить значение в канал ch до того, как горутина начнет его считывать.
Исправленный код:
```go
package main

import "fmt"

func main() {
	ch := make(chan int)
	
	go func() {
		fmt.Println(<-ch)
	}()
	
	ch <- 1
}
```



